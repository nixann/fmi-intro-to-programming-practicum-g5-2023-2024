#include <iostream>

void printPowerSet(char arr[], unsigned size) {
	// Границите на размера на масива в условието в заданието са объркани
	// Трябва размерът да е по-малък или равен от 31, а не 2^31

	// Идеята е да се възползваме от двоичното представяне на числата и
	// да ги третираме не като числа, а като булеви вектори
	// Знаете, че можем да характеризираме едно подмножество чрез булев вектор
	// Той е с размера на оригиналното множество и 
	// на всяка позиция ни казва дали даденият елемент се среща (1) или не се среща (0) в подмножеството
	// Предимството на използването на числа вместо булеви масиви тук е, че
	// можем много лесно да генерираме следващия булев вектор (само увеличаваме сегашното число с 1)
	// Продължаваме така докато не стигнем числото 2^size, което има двоичен запис 11111...1, което ни казва пък
	// че всеки елемент се среща в подмножеството

	// i почва от 1, защото не искаме по условие да отпечатваме празното подмножество
	for (unsigned subsetBoolVector = 1; subsetBoolVector < (1 << size); subsetBoolVector++) {
		unsigned temp = subsetBoolVector;
		unsigned index = 0;
		while (temp) {
			if (temp & 1) {
				// По начина по който инкрементираме `index`
				// ще отпечатаме елементите наобратно, но в условието не се изисква точна подредба
				std::cout << arr[index] << " ";
			}
			index++;
			temp = temp >> 1;
		}
		std::cout << std::endl;
	}
}

int main() {
	char arr[] = { 'a', 'b', 'c', 'd', 'e' };
	printPowerSet(arr, 5);
}