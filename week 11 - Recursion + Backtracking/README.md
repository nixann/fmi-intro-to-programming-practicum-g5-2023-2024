# Задачи

## Задача 1
- Напишете функция, която сортира масив от цели числа, използвайки алгоритъма [Merge Sort](https://en.wikipedia.org/wiki/Merge_sort)

## Задача 2
- Напишете функция, която отпечатва на екрана всички валидни скобувани изрази с дължина `n`.
    * *Пример:*
    
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>n: 6</pre> | <pre>((()))<br>(()())<br>(())()<br>()(())<br>()()()</pre>  |

## Задача 3 !! **Основна задача** !!
- Напишете функция, която получава булева матрица, представяща лабиринт. Ако стойността в дадена клетка е 1, клетката е непроходима, а иначе е проходима. Функцията получава и 2 неотрицателни числа, които са началните координати на човечето, което ще обикаля лабиринта, движейки се нагоре, надолу, наляво, надясно. Считаме, че човечето е излязло от лабиринта, ако е стигнало до някоя от границите на матрицата (т.е. ако е стигнало най-горния ред, най-долният ред, най-лявата стена или най-дясната стена). Нека функцията да:
    * Връща дали човечето може да излезе от лабиринта
        * *Пример:*
  
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>Начални координати: 2 2<br> 0 1 0 0 <br> 0 1 1 0 <br> 0 0 1 0 <br> 0 0 0 0</pre> | <pre>true</pre>  |

     *
         * *Пример:*
  
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>Начални координати: 2 2<br> 1 1 0 0 <br> 0 0 1 0 <br> 0 0 1 0 <br> 0 0 0 0</pre> | <pre>false</pre>  |
  <br>
  
    * Връща списък от координатите на някой от пътищата, по които може да излезе човечето (нека като допълнителен параметър към функцията да се подаде и целочислена променлива, в която накрая трябва да се запише дължината на намерения път). Ако няма такъв път, нека се върне `nullptr`.
        * *Пример:*
      
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>Начални координати: 2 2<br> 0 1 0 0 <br> 0 1 1 0 <br> 0 0 1 0 <br> 0 0 0 0</pre> | <pre>[[2, 2], [1, 2], [1, 1], [0, 1]], а записаната дължина е 4</pre>  |

     *
         * *Пример:*
  
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>Начални координати: 2 2<br> 0 0 0 0 <br> 0 1 1 0 <br> 0 0 1 0 <br> 0 0 0 0</pre> | <pre>nullptr, а записаната дължина е 0</pre>  |
  <br>
  
    * Отпечатва всички незастъпващи се пътища, по които може да излезе човечето (т.е. всички пътища, които не повтарят клетки в себе си) 
        * *Пример:*
      
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>Начални координати: 3 3<br> 0 1 0 0 0 1 <br> 0 1 1 1 1 1 <br> 0 0 1 1 0 0 <br> 0 0 0 1 0 0 <br> 0 0 0 1 0 0 <br> 0 0 0 1 0 0</pre> | <pre>(3, 3) (4, 3) (5, 3) <br>(3, 3) (2, 3) (1, 3) (1, 4) (1, 5)<br>(3, 3) (2, 3) (2, 2) (1, 2) (1, 3) (1, 4) (1, 5)<br>(3, 3) (2, 3) (1, 3) (1, 2) (1, 1) (0, 1)<br>(3, 3) (2, 3) (2, 2) (1, 2) (1, 1) (0, 1)</pre>  |
  
    *  Връща най-краткия път, по който може да излезе човечето (отново в допълнителна променлива се записва дължината му). Ако няма такъв път, нека се върне `nullptr`.
        * *Пример:*
      
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>Начални координати: 3 3<br> 0 1 0 0 0 1 <br> 0 1 1 1 1 1 <br> 0 0 1 1 0 0 <br> 0 0 0 1 0 0 <br> 0 0 0 1 0 0 <br> 0 0 0 1 0 0</pre> | <pre>[[3, 3], [4, 3], [5, 3]], а записаната дължина е 3</pre>  |
 
## Задача 4
- Напишете програма, която получава 9x9 двумерна матрица от символи `board`, представляваща [судоку](https://en.wikipedia.org/wiki/Sudoku). Всеки елемент на матрицата е или някоя цифра от 1 до 9, или символът `.`, индикиращ празно квадратче. Нека програмата да попълни тази матрица, така че судокуто да е вече решено (приемете, че подаденото судоку винаги има поне едно решение).
