#include <iostream>

// Тук подаваме capacity по референция, защото искаме промяната да се окаже в main
// Ние го подадохме в час по указател и се налагаше да пишем звездички навсякъде
// Референциите правят абсолютно същото, просто ни спестяват звездичките (те са "синтактична захар" за указатели)

// Тъй като във функцията променяме самия указател arr (на arr присвояваме temp), то трябва тази промяна да се окаже в main
// Нали искаме като пренасочим arr в resize, в main трябва arr да не продължава да сочи към изтритата памет, а да се пренасочи и той
// Значи, трябва и самият указател да бъде подаден по референция.
void resize(int*& arr, int& capacity) {

	// Този масив ще се превърне в новия arr
	// Искаме новият arr да е с 2 пъти по-голям капацитет
	int* temp = new int[capacity * 2];

	// Копираме числата от стария в новия масив
	for (int i = 0; i < capacity; i++) {
		temp[i] = arr[i];
	}

	// Сега ще преместим указателя arr, за да сочи новия масив temp
	// Но първо трябва да се отървем от старата памет, защото вече не ни трябва
	delete[] arr;

	// Присвояването на указатели става директно
	// Вече arr сочи към масива, към който сочи и temp
	// Успяхме да "преоразмерим" arr, като просто го накарахме да сочи към нов масив, който е по-голям
	arr = temp;

	// Удвояваме стария капацитет, за да работи arr нормално след преместването
	capacity *= 2;
}

// Тук ще подадем currentSize и capacity по референции, защото може тази функция да ги промени по някакъв начин
// currentSize може да бъде променено от самия push_back, а capacity може да се промени от resize, която се вика от push_back
// element няма да се променя от функцията, така че няма нужда от референция или указател 
// resize също ще променя arr в main-а => пак трябва да подадем arr по референция
void push_back(int*& arr, int element, int& capacity, int& currentSize) {

	// Проверяваме първо дали текущият масив е пълен
	if (capacity == currentSize) {
		resize(arr, capacity);
	}

	// Ако сме стигнали дотук, то ние или сме преоразмерили, или не сме напълнили още масива
	// И в двата случая масивът не е пълен и спокойно можем да добавим елемент в края

	// Записваме елемент в края и увеличаваме текущата дължина
	arr[currentSize] = element;
	currentSize++;
}

int main() {

	// Първоначално си слагаме някакъв начален капацитет
	// Няма много значение колко ще бъде
	int capacity = 10;

	// Първоначално масивът е празен
	int currentSize = 0;

	int* arr = new int[capacity];

	// Когато имаме да въвеждаме числа до въвеждане на 0, ето каква е схемата, на контролното при доста от вас беше грешно:
	/*
		int input;
		std::cin >> input;

		while (input) {
			...
			std::cin >> input;
		}
	*/

	int input;
	std::cin >> input;

	while (input) {
		// С горните 2 функции все едно сме си реализирали списък от C#, Java, Python, ...
		// Тежката работа вече сме я свършили
		// Значи, можем просто да push-ваме елемент в края и не се тревожим за нищо друго
		push_back(arr, input, capacity, currentSize);
		std::cin >> input;
	}

	for (int i = currentSize - 1; i >= 0; i--) {
		std::cout << arr[i] << " ";
	}
	std::cout << std::endl;


	delete[] arr;
}