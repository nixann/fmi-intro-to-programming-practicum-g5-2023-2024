#include <iostream>

const int MAX_SIZE = 50;

void spiralTraversalv2(char matrix[][MAX_SIZE], int size) {
	int indent = 0;

	while (indent <= size - 1 - indent) {
		// Ето тук е разликата - циклим до size - 1 - indent, а не size - 2 - indent
		for (int i = indent; i < size - indent; i++) {
			std::cout << matrix[indent][i] << " ";
		}

		// И тук започваме от indent + 1, а не от indent
		for (int i = indent + 1; i < size - 1 - indent; i++) {
			std::cout << matrix[i][size - 1 - indent] << " ";
		}

		for (int i = size - 1 - indent; i > indent; i--) {
			std::cout << matrix[size - 1 - indent][i] << " ";
		}

		for (int i = size - 1 - indent; i > indent; i--) {
			std::cout << matrix[i][indent] << " ";
		}
		indent++;
	}
	std::cout << std::endl;
}


void spiralTraversal(char matrix[][MAX_SIZE], int size) {

	// Спираловидното обхождане ще го разбием на няколко стъпки.
	// Нека матрицата изглежда така:
	//		x x x x x x
	//		x & & & & x
	//		x & o o & x
	//		x & o o & x
	//		x & & & & x
	//		x x x x x x
	// Забелязваме, че спираловидното обхождане се повтаря по пръстени
	// т.е. след като извървим периферията на нашата 6x6 матрица, която е съставена от хиксове (x)
	// ще трябва да извървим периферията на вътрешната 4x4 матрица, която е съставена от амперсани (&)
	// след това на вътрешната 2x2 матрица, която е съставена от кръгчета (о) и така нататък...
	// 
	// Сега, ако се фокусираме само върху периферията на първоначалната матрица,
	// можем да разбием нейното обхождане на 4 части:
	//		# # # # # $
	//		+ . . . . $
	//		+ . . . . $
	//		+ . . . . $
	//		+ . . . . $
	//		+ & & & & &	
	// 1) - обхождане на горната част отляво надясно (това са хаштаговете (#))
	// 2) - обхождане на дясната част отгоре надолу (това са доларите ($))
	// 3) - обхождане на долната част отдясно наляво (това са амперсаните (&))
	// 4) - обхождане на лявата част отдолу нагоре (това са плюсовете (+))
	// 
	// Всички тези движения са прости и можем да ги направим с по 1 цикъл
	// Тоест ще ни трябват 4 отделни цикъла за обхождането на една периферия
	// Същото това обхождане ще го повтаряме за вътрешните по-малки матрици.
	// Но как ще нагодим индексите?
	// За най-външната матрица обхожданията ще започват и завършват в следните елементи:
	// 
	//		1) - от (0, 0) до (0, 4)
	//		2) - от (0, 5) до (4, 5)
	//		3) - от (5, 5) до (5, 1)
	//		4) - от (5, 0) до (1, 0)

	// или в по-общия случай за произволен размер size това ще бъде:
	//		1) - от (0, 0) до (0, size - 2)
	//		2) - от (0, size - 1) до (size - 2, size - 1)
	//		3) - от (size - 1, size - 1) до (size - 1, 1)
	//		4) - от (size - 1, 0) до (1, 0)

	// Сега това е само за най-външната периферия. Ако си разпишем индексите за периферията на следващата вътрешна матрица в нашия пример ще имаме:
	//		1) - от (1, 1) до (1, 3)
	//		2) - от (1, 4) до (3, 4)
	//		3) - от (4, 4) до (4, 2)
	//		4) - от (4, 1) до (2, 1)

	// Но забележете, че тези индекси са всъщност индексите при обхождане на най-външната периферия с прибавени и извадени единици на някои места:
	//		1) - от (0 + 1, 0 + 1) до (0 + 1, 4 - 1)
	//		2) - от (0 + 1, 5 - 1) до (4 - 1, 5 - 1)
	//		3) - от (5 - 1, 5 - 1) до (5 - 1, 1 + 1)
	//		4) - от (5 - 1, 0 + 1) до (1 + 1, 0 + 1)

	// С това открихме зависимост между индексите на 0-вия най-външен и на 1-вия най-външен слой
	// Аналогична е зависимостта между 0-вия и n-тия най-вътрешен слой:
	//		1) - от (0 + n, 0 + n) до (0 + n, 4 - n)
	//		2) - от (0 + n, 5 - n) до (4 - n, 5 - n)
	//		3) - от (5 - n, 5 - n) до (5 - n, 1 + n)
	//		4) - от (5 - n, 0 + n) до (1 + n, 0 + n)

	// Значи можем да циклим по номера на слоя (в кода съм го кръстил indent) и да обхождаме чрез тази зависимост по периметъра на слоя
	// Въпросът е до кога ще циклим? 
	// Ще циклим докато indent <= size - 1 - indent, т.е. докато първият индекс на даден ред/колона се намира преди последния

	int indent = 0;

	while (indent <= size - 1 - indent) {
		// Обхождане на горната част
		for (int i = indent; i <= size - 2 - indent; i++) {
			std::cout << matrix[indent][i] << " ";
		}

		// Обхождане на дясната част
		for (int i = indent; i <= size - 2 - indent; i++) {
			std::cout << matrix[i][size - 1 - indent] << " ";
		}

		// Обхождане на долната част
		for (int i = size - 1 - indent; i >= 1 + indent; i--) {
			std::cout << matrix[size - 1 - indent][i] << " ";
		}

		// Обхождане на лявата част
		for (int i = size - 1 - indent; i >= 1 + indent; i--) {
			std::cout << matrix[i][indent] << " ";
		}

		// Преминаване към по-вътрешна матрица
		indent++;
	}

	// Проблем!
	// Ако indent == size - 1 - indent и оригиналната матрица има нечетен размер,
	// то ще ни остане да обходим единствения елемент по средата
	// Но ако погледнете внимателно циклите, никой от тях няма да се изпълни
	// . . .
	// . x . <- Ето този x няма да го хванем
	// . . .

	// Затова трябва отделно да се погрижим за този елемент и да го отпечатаме
	if (size % 2 != 0) {
		std::cout << matrix[size / 2][size / 2] << std::endl;
	}

	// Това решение е вярно и ще работи коректно
	// Оставил съм във функцията spiralTraversalv2 и още едно подобно.
	// Разликата е, че позволяваме първият цикъл да цикли с още 1 елемент напред,
	// а вторият започва с 1 елемент по-късно
	// Тази асиметричност ни позволява да хванем този среден елемент без допълнителна проверка
	// Също така вторият вариант по-лесно може да се направи да работи и с неквадратни матрици
}

int main() {
	char matrix[][MAX_SIZE] = {
		{'a', 'b', 'c', 'd', 'e'},
		{'f', 'g', 'h', 'i', 'j'},
		{'k', 'l', 'm', 'n', 'o'},
		{'p', 'q', 'r', 's', 't'},
		{'u', 'v', 'w', 'x', 'y'},
	};
	spiralTraversal(matrix, 4);
}