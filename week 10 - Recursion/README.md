# Рекурсия

- Рекурсивните функции са по принцип 2 вида:
     <br>
     <br>
    * Линейна рекурсия - само 1 рекурсивно извикване на функцията в тялото ѝ
        * *Пример:*
        ```c++
        int factorial(int n) {
            if(n == 0) return 1;
            return n * factorial(n - 1);
        }
        ```
        Линейната рекурсия е аналогична на математическата индукция. Има база(дъно), индуктивно предположение(т.е. допускаме, че функцията `factorial(n - 1)` вече си е свършила работата за по-малкия аргумент) и стъпка (какво ще направим с вече готовия резултат от рекурсивното извикване - в примера това е `return n * ...`).
      <br>
      <br>
      <br>
    * Дървовидна рекурсия - повече от 1 извиквания на самата функция в тялото ѝ
        * *Пример:*
        ```c++
        int fib(int n) {
            if(n == 1 || n == 2) return 1;
            return fib(n - 1) + fib(n - 2);
        }
        ```
        Дървовидната рекурсия пък е аналогична на силната индукция. Отново допускаме, че вече `fib(n - 1)` и `fib(n - 2)` са ни изчислени и стъпката е просто да ги съберем. Както при силната индукция, тъй като имаме повече от 1 обръщане назад (повече от 1 рекурсивно извикване), то ще трябва да имаме повече от 1 дъно.

# Задачи

(Във всички задачи е **ЗАДЪЛЖИТЕЛНО** да използвате рекурсия.)

## Задача 1
- Напишете функция, която приема целите положителни числа $n$ и $m$ и връща $n^m$.

## Задача 2
- Напишете функция, която приема масив от цели числа и цяло число и връща дали числото се съдържа в масива. Напишете функцията по 2 различни начина.

## Задача 3
- Напишете функция, която приема масив от цели положителни числа и връща дали в масива има просто число

 ## Задача 4
- Напишете функция, която приема масив от цели числа и цяло положително число `n` и връща дали сумата от цифрите на всяко число от масива дава остатък 0 при деление на `n`

## Задача 5
- Напишете функция, която приема масив от цели числа и намира сумата от елементите на масива.

## Задача 6
- Напишете функция, която приема целите положителни числа $n$ и $m$ и връща $n^m$, като използвате алгоритъма за бързо степенуване (https://en.wikipedia.org/wiki/Exponentiation_by_squaring). Идеята на алгоритъма е следната:

$$
x^n=
\begin{cases}
    x \cdot (x^2)^{\frac{n - 1}{2}}, & \text{ако } n \text{ е нечетно} \\
    (x^2)^{\frac{n}{2}}, & \text{ако } n \text{ е четно}
\end{cases}
$$

## Задача 7
- Напишете функция, която приема низ и го отпечатва наобратно буква по буква на конзолата.

## Задача 8
- Напишете булева функция, която приема низ и връща дали низът е палиндром (т.е. дали като се прочете низът отляво надясно, е същото като да се прочете отдясно наляво).

## Задача 9
- Напишете функция, която приема низ, който е *израз*. Ето какво наричаме *израз*:
    * `"(a)"`, където `a` е неотрицателно число
    * `"(b op c)"`, където `b` и `c` са *изрази*, а `op` е една от следните операции: `+`, `-`, `*`, `/`.
    * a) Нека функцията да пресмята дадения *израз*.
        * *Пример:*
    
        | Вход  | Изход |
        | ------------- | ------------- |
        | <pre>"(((8) / ((3) + (2))) + ((25) - ((3) * (9))))"</pre> | <pre>-0.4</pre>  |

  <br>
  
    * б) Модифицирайте функцията, така че да пресмята всеки *израз*, в който излишните скоби около дадено число са изпуснати:
        * *Пример:*
    
        | Вход  | Изход |
        | ------------- | ------------- |
        | <pre>"((8 / (3 + 2)) + (25 - (3 * 9)))"</pre> | <pre>-0.4</pre>  |

## Задача 10
- Напишете функция, която приема масив от символи `src` и цяло неотрицателно число `length` и отпечатва на екрана всички думи с дължина `length`, които съдържат само букви от `src`.
    * *Пример:*
    
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>src: [a, b]<br>length: 3</pre> | <pre>aaa<br>aab<br>aba<br>abb<br>baa<br>bab<br>bba<br>bbb<br></pre>  |
