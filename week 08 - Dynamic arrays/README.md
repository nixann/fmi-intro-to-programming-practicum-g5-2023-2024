# Как се работи с динамична памет

- **ВИНАГИ** след като ползваме динамична памет, трябва после да я изчистим
    * *Пример:*

  ```c++
  int* arr = new int[10];

  ...

  delete[] arr; // Не забравяйте това!
  ```

- Динамичните масиви могат да имат дължина, която е променлива (т.е. не е нужно да е константа както при статичните)
    * *Пример:*

  ```c++
  unsigned n;
  std::cin >> n;
  int* arr = new int[n];

  for(unsigned i = 0; i < n; i++) {
      std::cin >> arr[i];
  }
  
  ...
  
  delete[] arr;
  ```

- За разлика от статичните масиви, динамичните могат да се създават и да бъдат връщани от функция. Но **ТРЯБВА** в main функцията пак да бъдат изтрити
    * *Пример:*

  ```c++
  int* getUserInput() {
    unsigned n;
    std::cin >> n;
    int* arr = new int[n];
  
    for(unsigned i = 0; i < n; i++) {
        std::cin >> arr[i];
    }

    return arr;
  }
  
  int main() {
     int* userInput = getUserInput();

     ...

     delete[] userInput; // Отново да не се забравя!
  }
  ```

- Ето как се създават и трият многомерни масиви
    * *Пример:*

  ```c++
     // Всичко това е за инициализиране/въвеждане
     int** matrix = new int*[numRows];
     for(int i = 0; i < numRows; i++) {
        matrix[i] = new int[numCols];
        // Ако искаме като създаваме матрицата и едновременно да я въведем от потребителя,
        // можем да добавим и това:
        for(int j = 0; j < numCols; j++) {
            std::cin >> matrix[i][j];
        }
     }

      ...

      // Всичко това е за изтриване
      for(int i = 0; i < numRows; i++) {
          delete[] matrix[i];
      }
      delete[] matrix;
  ```
  
- Тъй като динамичните масиви са просто указатели, подаването им във функция е все едно подаваме обикновени указатели
    * *Пример:*

  ```c++
     void func(int* arr, int size) { ... }
     void func(int** matrix, int rows, int cols) { ... }
     void func(int*** tensor, int dim1, int dim2, int dim3) { ... }
     ...
  ```
  
# Задачи

## Задача 1
- Напишете програма, която въвежда от конзолата 2 цели неотрицателни числа $N$ и $M$ както и двумерен масив $matrix$ с размери $N×M$ (Тук $N$ и $M$ не са константи и не са ограничено, значи не можем да използваме статичен масив и ни трябва динамичен), такъв че всеки негов ред да съдържа всички числа в интервала $[0, M - 1]$. Да се отпечатат на отделни редове верижките, които се получават, като започнем от първия ред и отиваме на всеки следващ ред, като индекса на колоната се определя от предишния елемент на предходния ред.
    * *Пример:*

$$
N = 4 \quad M = 5
$$

$$
\begin{matrix}
\textcolor{red}{1}  & \textcolor{blue}{0} & \textcolor{green}{4}  & \textcolor{orange}{2} & \textcolor{purple}{3} \\
\textcolor{blue}{2}  & \textcolor{red}{3} & \textcolor{orange}{0} & \textcolor{purple}{4} & \textcolor{green}{1}  \\
\textcolor{orange}{0}  & \textcolor{green}{3} & \textcolor{blue}{4} & \textcolor{red}{1} & \textcolor{purple}{2}  \\
\textcolor{orange}{1}  & \textcolor{red}{2} & \textcolor{purple}{4} & \textcolor{green}{3} & \textcolor{blue}{0}
\end{matrix}
$$

$$
\begin{matrix}
Изход: \\
\textcolor{red}{1 3 1 2} \\
\textcolor{blue}{0 2 4 0} \\
\textcolor{green}{4 1 3 3} \\
\textcolor{orange}{2 0 0 1} \\
\textcolor{purple}{3 4 2 4}
\end{matrix}
$$

## Задача 2
- Напишете програма, която въвежда от клавиатурата **неограничен** брой числа до въвеждане на 0 и след това ги отпечатва в обратен ред.<br><br>
Тъй като предварително никъде не се казва колко елемента ще въведе потребителят, обикновеният динамичен масив няма да свърши работа. Затова ще си направим преоразмеряващ се масив. Ето как става:<br>
    * Програмата трябва да поддържа текущ капацитет на масива и текущ индекс на последния въведен елемент.
    * Напишете функция `resize`, която приема като аргумент масив и го **променя**, така че новият му капацитет да е 2 пъти по-голям от стария, а елементите му да са си останали същите.
    * Напишете функция `push_back`, която приема като аргумент масив, число и текущият индекс, като добавя числото в края на масива (ако има нужда, първо да се преоразмери масивът).
    * Остатъкът от задачата вече се прави лесно.
 
## Задача 3
- Напишете функция, която приема масив, число и индекс и вмъква числото на този индекс в масива.
<details>
<summary>Жокер</summary>
<br>
Използвайте функцията за преоразмеряване от предната задача
<br>
</details>

## Задача 4
- Напишете функция, която приема масив от цели числа и цяло положително число `p` и групира числата, спрямо остатъка който дават при деление на `p`.
    * *Пример*:

   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>p: 2<br>[1, 2, 3, 4, 5]</pre> | <pre>[[2, 4], [1, 3, 5]]</pre>  |
   | <pre>p: 5<br>[15, 16, 20, 22]</pre> | <pre>[[15, 20], [16], [22]]</pre>  |

## Задача 5
- Напишете функция, която приема масив и число `k` и връща матрица, `i`-тият ред на която съдържа `i`-тата последователност от `k` елемента на масива. (Приемаме, че размерът на масива се дели на `k`)
    * *Пример*:
      
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>k: 3<br> 1 2 3 4 5 6 7 8 9</pre> | <pre>1 2 3<br>4 5 6<br>7 8 9</pre>  |

## Задача 6
- Напишете функция, която приема масив `pool` от цели числа и масив `sizes` от неотрицателни цели числа, като сумата на елементите на масива `sizes` е равна на размера на `pool`. Нека функцията да връща нов масив `staircase`, чиито елементи са масиви, представляващи `i`-тото парче на масива `pool` с размер `sizes[i]`, и тези парчета са сортирани по дължина във възходящ ред. (`staircase` е т.нар. *jagged array*)
    * *Пример*:
      
   | Вход  | Изход |
   | ------------- | ------------- |
   | <pre>sizes: 2 5 4 7 1<br>pool: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</pre> | <pre>staircase(преди сортиране): 1 2<br>                            3 4 5 6 7<br>                            8 9 10 11<br>                            12 13 14 15 16 17 18<br>                            19<br><br>staircase(след сортиране):  19<br>                            1 2<br>                            8 9 10 11<br>                            3 4 5 6 7<br>                            12 13 14 15 16 17 18</pre>  |
